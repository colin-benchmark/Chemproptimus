#include "status.h"
#include "firing/firing.h"
#include "firing/firing_attributes.h"
#include "firing/firing_methods.h"
#include "firing/firing_callbacks.h"
#include "firing/firing_instance.h"
#include "firing_interface.h"
#include <stdint.h>
#include <string.h>

/**********************************************************
 * Autogenerated code. Don't edit as it'll be overwritten
 *********************************************************/

status_t firing_read_handler(
    uint8_t attribute_id,
    uint16_t first,
    uint16_t last,
    uint8_t *output,
    uint8_t output_len,
    uint8_t *bytes_written
) {
    status_t status = STATUS_SUCCESS;
    uint8_t bytes_to_write = 0;

    if (first > last) {
        return STATUS_COMMS_INVALID_ROWS;
    }

    switch (attribute_id) {
        
        case FIRING_ATTRIBUTE_INDUCTOR_CHARGE_TIME_ID:
            if (last >= FIRING_ATTRIBUTE_INDUCTOR_CHARGE_TIME_ROWS) {
                last = FIRING_ATTRIBUTE_INDUCTOR_CHARGE_TIME_ROWS - 1;
            }
            bytes_to_write = sizeof(uint16_t) * (last - first + 1);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows=4 read_callback= */
            memcpy(output, &firing_inst.inductor_charge_time[first], bytes_to_write);
            break;
        
        case FIRING_ATTRIBUTE_FIRING_PATTERN_ID:
            if (last >= FIRING_ATTRIBUTE_FIRING_PATTERN_ROWS) {
                last = FIRING_ATTRIBUTE_FIRING_PATTERN_ROWS - 1;
            }
            bytes_to_write = sizeof(uint8_t) * (last - first + 1);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows=16 read_callback=True */
            status = firing_firing_pattern_read_callback((uint8_t *)output, first, last);
            break;
        
        case FIRING_ATTRIBUTE_CAPACITOR_CHARGE_TIME_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback=True */
            status = firing_capacitor_charge_time_read_callback((uint16_t *)output);
            break;
        
        case FIRING_ATTRIBUTE_SHOTS_REMAINING_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &firing_inst.shots_remaining, bytes_to_write);
            break;
        
        case FIRING_ATTRIBUTE_CYCLES_REMAINING_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &firing_inst.cycles_remaining, bytes_to_write);
            break;
        
        case FIRING_ATTRIBUTE_TARGET_POWER_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &firing_inst.target_power, bytes_to_write);
            break;
        
        case FIRING_ATTRIBUTE_FIRING_MODE_ID:
            bytes_to_write = sizeof(uint8_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &firing_inst.firing_mode, bytes_to_write);
            break;
        
        case FIRING_ATTRIBUTE_ENABLED_ID:
            bytes_to_write = sizeof(bool);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &firing_inst.enabled, bytes_to_write);
            break;
        
        case FIRING_ATTRIBUTE_SAFETY_OVERRIDE_ID:
            bytes_to_write = sizeof(bool);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &firing_inst.safety_override, bytes_to_write);
            break;
        
        case FIRING_ATTRIBUTE_TOTAL_ISP_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &firing_inst.total_isp, bytes_to_write);
            break;
        
        default:
            return STATUS_COMMS_INVALID_ATTRIB_ID;
    }

    *bytes_written = bytes_to_write;
    return status;
}

status_t firing_write_handler(
    uint8_t attribute_id,
    uint16_t first,
    uint16_t last,
    uint8_t *input,
    uint8_t input_len
) {
    status_t status = STATUS_SUCCESS;
    uint8_t bytes_to_write = 0;

    if (first > last) {
        return STATUS_COMMS_INVALID_ROWS;
    }

    switch (attribute_id) {
        
        case FIRING_ATTRIBUTE_INDUCTOR_CHARGE_TIME_ID:
            if (last >= FIRING_ATTRIBUTE_INDUCTOR_CHARGE_TIME_ROWS) {
                last = FIRING_ATTRIBUTE_INDUCTOR_CHARGE_TIME_ROWS - 1;
            }
            bytes_to_write = sizeof(uint16_t) * (last - first + 1);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            memcpy(&firing_inst.inductor_charge_time[first], input, bytes_to_write);
            break;
            
        case FIRING_ATTRIBUTE_FIRING_PATTERN_ID:
            if (last >= FIRING_ATTRIBUTE_FIRING_PATTERN_ROWS) {
                last = FIRING_ATTRIBUTE_FIRING_PATTERN_ROWS - 1;
            }
            bytes_to_write = sizeof(uint8_t) * (last - first + 1);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            status = firing_firing_pattern_write_callback((uint8_t *)input, first, last);
            break;
            
        case FIRING_ATTRIBUTE_CAPACITOR_CHARGE_TIME_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            status = firing_capacitor_charge_time_write_callback((uint16_t *)input);
            break;
            
        case FIRING_ATTRIBUTE_SHOTS_REMAINING_ID:
            return STATUS_COMMS_READONLY;
            
        case FIRING_ATTRIBUTE_CYCLES_REMAINING_ID:
            return STATUS_COMMS_READONLY;
            
        case FIRING_ATTRIBUTE_TARGET_POWER_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            memcpy(&firing_inst.target_power, input, bytes_to_write);
            break;
            
        case FIRING_ATTRIBUTE_FIRING_MODE_ID:
            bytes_to_write = sizeof(uint8_t);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            memcpy(&firing_inst.firing_mode, input, bytes_to_write);
            break;
            
        case FIRING_ATTRIBUTE_ENABLED_ID:
            bytes_to_write = sizeof(bool);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            memcpy(&firing_inst.enabled, input, bytes_to_write);
            break;
            
        case FIRING_ATTRIBUTE_SAFETY_OVERRIDE_ID:
            bytes_to_write = sizeof(bool);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            memcpy(&firing_inst.safety_override, input, bytes_to_write);
            break;
            
        case FIRING_ATTRIBUTE_TOTAL_ISP_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            memcpy(&firing_inst.total_isp, input, bytes_to_write);
            break;
            
        default:
            return STATUS_COMMS_INVALID_ATTRIB_ID;
    }

    return status;
}

status_t firing_method_handler(
    uint8_t method_id,
    uint8_t *input,
    uint8_t input_len
) {
    status_t status = STATUS_ERROR;

    
    switch (method_id) {
        
        case FIRING_METHOD_FIRE_SHOTS_ID:
            if (input_len != FIRING_METHOD_FIRE_SHOTS_PARAM_BYTES) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            struct __attribute__((__packed__)) _firing_fire_shots_parameters {
                int8_t thruster;
                int16_t shots;
            } firing_fire_shots_parameters;
            memcpy(&firing_fire_shots_parameters, input, input_len);

            status = firing_fire_shots(
                firing_fire_shots_parameters.thruster,
                firing_fire_shots_parameters.shots
            );
            break;
            
        case FIRING_METHOD_FIRE_CYCLES_ID:
            if (input_len != FIRING_METHOD_FIRE_CYCLES_PARAM_BYTES) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            struct __attribute__((__packed__)) _firing_fire_cycles_parameters {
                uint16_t cycles;
            } firing_fire_cycles_parameters;
            memcpy(&firing_fire_cycles_parameters, input, input_len);

            status = firing_fire_cycles(
                firing_fire_cycles_parameters.cycles
            );
            break;
            
        default:
            status = STATUS_COMMS_INVALID_METHOD_ID;
    }
    

    return status;
}
