#include "comms_status.h"
#include "status.h"
#include "eeprom/eeprom.h"
#include "eeprom/eeprom_attributes.h"
#include "eeprom/eeprom_methods.h"
#include "eeprom_instances.h"
#include "eeprom_interface.h"
#include <stdint.h>
#include <string.h>

/**********************************************************
 * Autogenerated code. Don't edit as it'll be overwritten
 *********************************************************/

status_t eeprom_read_handler(
    uint8_t attribute_id,
    uint16_t first,
    uint16_t last,
    uint8_t *output,
    uint8_t output_len,
    uint8_t *bytes_written
) {
    uint8_t bytes_to_write = 0;

    if (first > last) {
        return COMMS_STATUS_INVALID_ROWS;
    }

    switch (attribute_id) {
        
        case EEPROM_ATTRIBUTE_CODEWORK_ID:
            bytes_to_write = sizeof(uint32_t);
            if (bytes_to_write > output_len) {
                return COMMS_STATUS_INSUFFICIENT_BUFFER_SPACE;
            }
            memcpy(output, &eeprom_inst.codework, bytes_to_write);
            break;
        
        default:
            return COMMS_STATUS_INVALID_ATTRIB_ID;
    }

    *bytes_written = bytes_to_write;
    return STATUS_SUCCESS;
}

status_t eeprom_write_handler(
    uint8_t instance_n,
    uint8_t attribute_id,
    uint16_t first,
    uint16_t last,
    uint8_t *input,
    uint8_t input_len
) {
    uint8_t bytes_to_write = 0;

    if (instance_n >= EEPROM_INSTANCES_N) {
        return COMMS_STATUS_INVALID_INSTANCE_ID;
    }

    if (first > last) {
        return COMMS_STATUS_INVALID_ROWS;
    }

    switch (attribute_id) {
        
        case EEPROM_ATTRIBUTE_CODEWORK_ID:
            bytes_to_write = sizeof(uint32_t);
            if (bytes_to_write != input_len) {
                return COMMS_STATUS_INCORRECT_INPUT_DATA;
            }
            memcpy(&eeprom_inst.codework, input, bytes_to_write);
            break;
            
        default:
            return COMMS_STATUS_INVALID_ATTRIB_ID;
    }

    return STATUS_SUCCESS;
}

status_t eeprom_method_handler(
    uint8_t instance_n,
    uint8_t method_id,
    uint8_t *input,
    uint8_t input_len
) {
    status_t status = STATUS_ERROR;

    if (instance_n >= EEPROM_INSTANCES_N) {
        return COMMS_STATUS_INVALID_INSTANCE_ID;
    }

    switch (method_id) {
        
        case EEPROM_METHOD_RESET_ID:
            status = eeprom_reset();
            break;
            
        default:
            status = COMMS_STATUS_INVALID_METHOD_ID;
    }

    return status;
}
