#include "status.h"
#include "device/device_component.h"
#include "device/device_attributes.h"
#include "device/device_methods.h"
#include "device/device_callbacks.h"
#include "device/device_instance.h"
#include "device_interface.h"
#include <stdint.h>
#include <string.h>

/**********************************************************
 * Autogenerated code. Don't edit as it'll be overwritten
 *********************************************************/

status_t device_read_handler(
    uint8_t attribute_id,
    uint16_t first,
    uint16_t last,
    uint8_t *output,
    uint8_t output_len,
    uint8_t *bytes_written
) {
    status_t status = STATUS_SUCCESS;
    uint8_t bytes_to_write = 0;

    if (first > last) {
        return STATUS_COMMS_INVALID_ROWS;
    }

    switch (attribute_id) {
        
        case DEVICE_ATTRIBUTE_VERSION_ID:
            if (last >= DEVICE_ATTRIBUTE_VERSION_ROWS) {
                last = DEVICE_ATTRIBUTE_VERSION_ROWS - 1;
            }
            bytes_to_write = sizeof(uint8_t) * (last - first + 1);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows=3 read_callback= */
            memcpy(output, &device_inst.version[first], bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_MANUFACTURER_ID:
            if (last >= DEVICE_ATTRIBUTE_MANUFACTURER_ROWS) {
                last = DEVICE_ATTRIBUTE_MANUFACTURER_ROWS - 1;
            }
            bytes_to_write = sizeof(uint8_t) * (last - first + 1);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows=9 read_callback= */
            memcpy(output, &device_inst.manufacturer[first], bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_SERIAL_NUMBER_ID:
            if (last >= DEVICE_ATTRIBUTE_SERIAL_NUMBER_ROWS) {
                last = DEVICE_ATTRIBUTE_SERIAL_NUMBER_ROWS - 1;
            }
            bytes_to_write = sizeof(uint8_t) * (last - first + 1);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows=8 read_callback= */
            memcpy(output, &device_inst.serial_number[first], bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_BUILD_ID:
            bytes_to_write = sizeof(uint32_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &device_inst.build, bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_BOOTCOUNTER_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &device_inst.bootcounter, bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_STATUS_ID:
            bytes_to_write = sizeof(uint16_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &device_inst.status, bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_LAST_ERROR_ID:
            bytes_to_write = sizeof(uint8_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &device_inst.last_error, bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_LOG_LEVEL_ID:
            bytes_to_write = sizeof(uint8_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &device_inst.log_level, bytes_to_write);
            break;
        
        case DEVICE_ATTRIBUTE_CHECKSUM_ID:
            bytes_to_write = sizeof(uint32_t);
            if (bytes_to_write > output_len) {
                return STATUS_COMMS_INSUFFICIENT_BUFFER_SPACE;
            }
            /* rows= read_callback= */
            memcpy(output, &device_inst.checksum, bytes_to_write);
            break;
        
        default:
            return STATUS_COMMS_INVALID_ATTRIB_ID;
    }

    *bytes_written = bytes_to_write;
    return status;
}

status_t device_write_handler(
    uint8_t attribute_id,
    uint16_t first,
    uint16_t last,
    uint8_t *input,
    uint8_t input_len
) {
    status_t status = STATUS_SUCCESS;
    uint8_t bytes_to_write = 0;

    if (first > last) {
        return STATUS_COMMS_INVALID_ROWS;
    }

    switch (attribute_id) {
        
        case DEVICE_ATTRIBUTE_VERSION_ID:
            return STATUS_COMMS_READONLY;
            
        case DEVICE_ATTRIBUTE_MANUFACTURER_ID:
            return STATUS_COMMS_READONLY;
            
        case DEVICE_ATTRIBUTE_SERIAL_NUMBER_ID:
            return STATUS_COMMS_READONLY;
            
        case DEVICE_ATTRIBUTE_BUILD_ID:
            return STATUS_COMMS_READONLY;
            
        case DEVICE_ATTRIBUTE_BOOTCOUNTER_ID:
            return STATUS_COMMS_READONLY;
            
        case DEVICE_ATTRIBUTE_STATUS_ID:
            return STATUS_COMMS_READONLY;
            
        case DEVICE_ATTRIBUTE_LAST_ERROR_ID:
            return STATUS_COMMS_READONLY;
            
        case DEVICE_ATTRIBUTE_LOG_LEVEL_ID:
            bytes_to_write = sizeof(uint8_t);
            if (bytes_to_write != input_len) {
                return STATUS_COMMS_INCORRECT_INPUT_DATA;
            }
            memcpy(&device_inst.log_level, input, bytes_to_write);
            break;
            
        case DEVICE_ATTRIBUTE_CHECKSUM_ID:
            return STATUS_COMMS_READONLY;
            
        default:
            return STATUS_COMMS_INVALID_ATTRIB_ID;
    }

    return status;
}

status_t device_method_handler(
    uint8_t method_id,
    uint8_t *input,
    uint8_t input_len
) {
    status_t status = STATUS_ERROR;

    
    switch (method_id) {
        
        case DEVICE_METHOD_PRINT_VERISON_ID:
            status = device_print_verison();
            break;
            
        case DEVICE_METHOD_REBOOT_ID:
            status = device_reboot();
            break;
            
        case DEVICE_METHOD_CALCULATE_CHECKSUM_ID:
            status = device_calculate_checksum();
            break;
            
        default:
            status = STATUS_COMMS_INVALID_METHOD_ID;
    }
    

    return status;
}
